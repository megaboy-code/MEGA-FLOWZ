// ==================== CHART SYSTEM ====================

// Chart rendering and datasets
function renderProfessionalChart(chartData, timeframe, symbol, indicators, indicators_data) {
    const ctx = document.getElementById('mainChart').getContext('2d');
    
    if (currentChart) currentChart.destroy();

    currentIndicatorValues = indicators || {};
    
    const professionalTheme = {
        primary: chartColors.line,
        background: chartColors.areaFill,
        grid: '#1E293B',
        text: '#F1F5F9',
        textSecondary: '#94A3B8',
        accent: '#8B5CF6'
    };

    let datasets = [];

    if (currentChartType === 'line') {
        datasets = createLineDataset(chartData, symbol, professionalTheme);
    } else if (currentChartType === 'area') {
        datasets = createAreaDataset(chartData, symbol, professionalTheme);
    } else if (currentChartType === 'candlestick') {
        datasets = createCandlestickDataset(chartData, symbol, professionalTheme);
    } else if (currentChartType === 'trend') {
        datasets = createLineDataset(chartData, symbol, professionalTheme);
    }

    datasets = datasets.concat(createIndicatorDatasets(indicators_data, professionalTheme));

    const chartType = currentChartType === 'candlestick' ? 'candlestick' : 'line';
    
    currentChart = new Chart(ctx, {
        type: chartType,
        data: { datasets: datasets },
        options: getEnhancedChartOptions(timeframe, professionalTheme)
    });

    initializeAxisIndicators();
    initializeCurrentPriceLine();
    initializeChartShiftTriangle();
    addCrosshairListeners();
    renderIndicatorsList();
    
    const latestPrice = chartData.length > 0 ? chartData[chartData.length - 1].y : 0;
    updateCurrentPrice(latestPrice);
    updateCurrentPriceLine(latestPrice, 'neutral');
    
    console.log(`âœ… Chart rendered: ${symbol} ${timeframe} (${currentChartType})`);
}

function loadChart(timeframe = 'H1') {
    const chartStatus = document.getElementById('chartStatus');
    if (!chartStatus) return;
    
    chartStatus.textContent = 'ðŸ”„ Loading...';
    
    const indicatorParams = buildIndicatorParameters();
    
    fetch(`/api/chart-data/${timeframe}?pair=${currentPair}&pyramid_style=${currentPyramidStyle}${indicatorParams}`)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        })
        .then(data => {
            if (data.error) {
                chartStatus.textContent = `âŒ ${data.error}`;
                return;
            }
            
            // Validate chart data before rendering
            if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
                chartStatus.textContent = 'âŒ No chart data received';
                return;
            }
            
            renderProfessionalChart(data.data, timeframe, currentPair, data.indicators, data.indicators_data);
            chartStatus.textContent = `âœ… ${currentPair} ${timeframe}`;
            currentTimeframe = timeframe;
            
            if (lastClickedPyramidBlock) {
                setTimeout(() => {
                    triggerTooltipAtTime(lastClickedPyramidBlock.time);
                    lastClickedPyramidBlock = null;
                }, 500);
            }
        })
        .catch(error => {
            console.error('Chart loading error:', error);
            chartStatus.textContent = 'âŒ Failed to load chart data';
        });
}

function buildIndicatorParameters() {
    let params = '';
    activeIndicators.forEach((config, indicatorId) => {
        const baseType = indicatorId.split('_')[0];
        
        switch(baseType) {
            case 'sma': case 'ema': case 'rsi':
                params += `&${baseType}_period=${config.period}`;
                break;
            case 'macd':
                params += `&${baseType}_fast=${config.fastPeriod}&${baseType}_slow=${config.slowPeriod}&${baseType}_signal=${config.signalPeriod}`;
                break;
            case 'bollinger':
                params += `&${baseType}_period=${config.period}&${baseType}_std=${config.stdDev}`;
                break;
            case 'stochastic':
                params += `&${baseType}_k=${config.kPeriod}&${baseType}_k_smooth=${config.kSmooth}&${baseType}_d_smooth=${config.dSmooth}`;
                break;
        }
        
        params += `&${baseType}_instance=${config.instanceNumber}`;
    });
    
    return params;
}

// Chart dataset creators
function createCandlestickDataset(priceData, symbol, theme) {
    return [{
        label: `${symbol} Price`,
        data: priceData,
        borderColor: theme.primary,
        backgroundColor: 'transparent',
        borderWidth: 2,
        pointRadius: 0,
        pointHoverRadius: 3,
        tension: 0.1,
        yAxisID: 'y',
        fill: false
    }];
}

function createLineDataset(priceData, symbol, theme) {
    if (currentChartType === 'trend') {
        return [{
            label: `${symbol} Price`, data: priceData,
            segment: { borderColor: (ctx) => {
                if (ctx.p0.parsed.y === ctx.p1.parsed.y) return theme.primary;
                return ctx.p1.parsed.y > ctx.p0.parsed.y ? chartColors.bull : chartColors.bear;
            }},
            borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, tension: 0.1, yAxisID: 'y', fill: false
        }];
    } else {
        return [{
            label: `${symbol} Price`, data: priceData, borderColor: theme.primary, backgroundColor: 'transparent',
            borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, tension: 0.1, yAxisID: 'y', fill: false
        }];
    }
}

function createAreaDataset(priceData, symbol, theme) {
    return [{
        label: `${symbol} Price`, data: priceData, borderColor: theme.primary, backgroundColor: theme.background,
        borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, tension: 0.1, yAxisID: 'y',
        fill: { target: 'origin', above: theme.background }
    }];
}

function createIndicatorDatasets(indicators_data, theme) {
    const datasets = [];
    if (!indicators_data) return datasets;
    
    activeIndicators.forEach((config, indicatorId) => {
        if (!config.visible) return;
        const baseType = indicatorId.split('_')[0];
        
        switch(baseType) {
            case 'bollinger':
                if (indicators_data.bollinger) {
                    const bb = indicators_data.bollinger;
                    datasets.push(
                        { label: `${config.name} Upper`, data: bb.upper, borderColor: config.color, borderWidth: 1, pointRadius: 0, yAxisID: 'y', fill: false },
                        { label: `${config.name} Middle`, data: bb.middle, borderColor: config.color, borderWidth: 1.5, pointRadius: 0, yAxisID: 'y', fill: false },
                        { label: `${config.name} Lower`, data: bb.lower, borderColor: config.color, borderWidth: 1, pointRadius: 0, yAxisID: 'y', fill: false }
                    );
                }
                break;
            case 'stochastic':
                if (indicators_data.stoch_k) {
                    datasets.push({ label: `${config.name} %K`, data: indicators_data.stoch_k, borderColor: config.color, borderWidth: 1.5, pointRadius: 0, yAxisID: 'y2', fill: false });
                }
                if (indicators_data.stoch_d) {
                    datasets.push({ label: `${config.name} %D`, data: indicators_data.stoch_d, borderColor: config.color, borderWidth: 1.5, borderDash: [5, 5], pointRadius: 0, yAxisID: 'y2', fill: false });
                }
                break;
            case 'supportresistance':
                if (indicators_data.support_resistance) {
                    datasets.push({ label: 'Support/Resistance', data: [], srLevels: indicators_data.support_resistance, supportColor: config.supportColor, resistanceColor: config.resistanceColor });
                }
                break;
            default:
                const instanceNumber = config.instanceNumber;
                const dataKeys = [`${baseType}_${config.period}`, `${baseType}_${instanceNumber}`, baseType, `${baseType}_20`, `${baseType}_12`];
                
                let indicatorData = null;
                for (const key of dataKeys) {
                    if (indicators_data[key]) {
                        indicatorData = indicators_data[key];
                        break;
                    }
                }
                
                if (indicatorData) {
                    datasets.push({
                        label: `${config.name} #${instanceNumber}`, data: indicatorData, borderColor: config.color, borderWidth: 1.5,
                        borderDash: baseType === 'ema' ? [2, 2] : [0, 0], pointRadius: 0, tension: 0, yAxisID: config.yAxis || 'y', fill: false
                    });
                }
                break;
        }
    });
    return datasets;
}

// Chart options and configuration
function getEnhancedChartOptions(timeframe, theme) {
    return {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            mode: 'nearest',
            intersect: false,
            axis: 'xy'
        },
        plugins: {
            legend: {
                display: false
            },
            tooltip: {
                enabled: false, // No hover tooltips - manual only
                mode: 'nearest',
                intersect: false,
                backgroundColor: 'rgba(15, 23, 42, 0.95)',
                titleColor: theme.text,
                bodyColor: theme.textSecondary,
                borderColor: theme.grid,
                borderWidth: 1,
                cornerRadius: 6,
                padding: 12,
                callbacks: {
                    title: function(context) {
                        const date = new Date(context[0].parsed.x);
                        return date.toLocaleDateString('en-US', {
                            weekday: 'short',
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        });
                    },
                    label: function(context) {
                        let label = context.dataset.label || '';
                        if (label) label += ': ';
                        if (context.parsed.y !== null) {
                            label += new Intl.NumberFormat('en-US', {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 5
                            }).format(context.parsed.y);
                        }
                        return label;
                    }
                }
            },
            zoom: {
                zoom: {
                    drag: {
                        enabled: false, // Disabled by default, enabled when zoom buttons clicked
                        modifierKey: null
                    },
                    wheel: {
                        enabled: false // No mouse wheel zoom
                    },
                    pinch: {
                        enabled: false // No trackpad pinch zoom
                    },
                    mode: 'xy'
                },
                pan: {
                    enabled: true,
                    mode: 'xy',
                    modifierKey: 'shift'
                },
                limits: {
                    x: { min: 'original', max: 'original' },
                    y: { min: 'original', max: 'original' }
                }
            }
        },
        scales: {
            x: {
                type: 'time',
                time: {
                    displayFormats: getProfessionalTimeFormats(timeframe)
                },
                grid: {
                    color: theme.grid,
                    drawBorder: true,
                    border: {
                        color: theme.grid,
                        width: 1
                    }
                },
                ticks: {
                    color: theme.textSecondary,
                    maxRotation: 0,
                    autoSkip: true,
                    maxTicksLimit: 8
                },
                border: { 
                    display: true,
                    color: theme.grid,
                    width: 1
                }
            },
            y: {
                position: 'right',
                grid: {
                    color: theme.grid,
                    drawBorder: true,
                    border: {
                        color: theme.grid,
                        width: 1
                    }
                },
                ticks: {
                    color: theme.textSecondary,
                    callback: (value) => value.toFixed(5),
                    maxTicksLimit: 10
                },
                border: { 
                    display: true,
                    color: theme.grid,
                    width: 1
                }
            },
            y2: {
                type: 'linear',
                position: 'left',
                grid: { drawOnChartArea: false },
                ticks: {
                    color: '#E2E8F0',
                    callback: (value) => value.toFixed(2),
                    maxTicksLimit: 5
                },
                border: { display: false },
                min: 0,
                max: 100
            }
        }
    };
}

// Current Price Line System - FIXED
function initializeCurrentPriceLine() {
    const chartWrapper = document.querySelector('.chart-wrapper');
    if (!chartWrapper) return;
    
    const existingLine = document.getElementById('currentPriceLine');
    if (existingLine) existingLine.remove();
    
    const currentPriceLine = document.createElement('div');
    currentPriceLine.id = 'currentPriceLine';
    currentPriceLine.className = 'current-price-line';
    currentPriceLine.style.display = 'none';
    
    chartWrapper.appendChild(currentPriceLine);
}

function updateCurrentPriceLine(price, direction) {
    const currentPriceLine = document.getElementById('currentPriceLine');
    if (!currentPriceLine || !currentChart) return;
    
    const chartArea = currentChart.chartArea;
    if (!chartArea) return;
    
    const yScale = currentChart.scales.y;
    const pixel = yScale.getPixelForValue(price);
    
    if (pixel >= chartArea.top && pixel <= chartArea.bottom) {
        currentPriceLine.style.display = 'block';
        currentPriceLine.style.top = `${pixel}px`;
        currentPriceLine.style.left = `${chartArea.left}px`;
        currentPriceLine.style.width = `${chartArea.right - chartArea.left}px`;
        
        // Set color based on direction
        if (direction === 'up') {
            currentPriceLine.classList.add('up');
            currentPriceLine.classList.remove('down', 'neutral');
        } else if (direction === 'down') {
            currentPriceLine.classList.add('down');
            currentPriceLine.classList.remove('up', 'neutral');
        } else {
            currentPriceLine.classList.add('neutral');
            currentPriceLine.classList.remove('up', 'down');
        }
    } else {
        currentPriceLine.style.display = 'none';
    }
}

// MT5 Chart Shift System - FIXED
let chartShiftTriangle = null;
let isDraggingShift = false;
let chartShiftAmount = 0;
const MAX_SHIFT_SPACE = 0.3; // 30% max shift space

function initializeChartShiftTriangle() {
    const chartWrapper = document.querySelector('.chart-wrapper');
    if (!chartWrapper) return;
    
    const existingTriangle = document.getElementById('chartShiftTriangle');
    if (existingTriangle) existingTriangle.remove();
    
    chartShiftTriangle = document.createElement('div');
    chartShiftTriangle.id = 'chartShiftTriangle';
    chartShiftTriangle.className = 'chart-shift-triangle';
    chartShiftTriangle.innerHTML = 'â–¼';
    chartShiftTriangle.style.display = 'block';
    
    chartWrapper.appendChild(chartShiftTriangle);
    setupShiftTriangleDrag();
    
    updateChartShiftPosition();
}

function setupShiftTriangleDrag() {
    if (!chartShiftTriangle) return;
    
    chartShiftTriangle.addEventListener('mousedown', startShiftDrag);
    document.addEventListener('mousemove', handleShiftDrag);
    document.addEventListener('mouseup', stopShiftDrag);
}

function startShiftDrag(e) {
    e.preventDefault();
    e.stopPropagation();
    isDraggingShift = true;
    chartShiftTriangle.classList.add('dragging');
    document.body.style.cursor = 'col-resize';
    
    console.log('ðŸ”„ Chart shift drag started');
}

function handleShiftDrag(e) {
    if (!isDraggingShift || !currentChart) return;
    
    const chartWrapper = document.querySelector('.chart-wrapper');
    const rect = chartWrapper.getBoundingClientRect();
    const clientX = e.clientX;
    
    if (!clientX) return;
    
    // Calculate shift amount based on mouse position
    const relativeX = (clientX - rect.left) / rect.width;
    chartShiftAmount = Math.max(0, Math.min(MAX_SHIFT_SPACE, 1 - relativeX));
    
    // Apply the shift to the chart
    applyChartShift();
    
    // Update visual position and show price/time
    updateChartShiftPosition();
    updateShiftPriceTimeDisplay(e);
}

function stopShiftDrag() {
    isDraggingShift = false;
    if (chartShiftTriangle) {
        chartShiftTriangle.classList.remove('dragging');
    }
    document.body.style.cursor = '';
    
    // Hide shift display when done dragging
    const shiftDisplay = document.getElementById('chartShiftDisplay');
    if (shiftDisplay) {
        shiftDisplay.style.display = 'none';
    }
    
    console.log('ðŸ”„ Chart shift drag ended');
}

function applyChartShift() {
    if (!currentChart) return;
    
    const xScale = currentChart.scales.x;
    if (!xScale) return;
    
    // Get the current visible range
    const currentMin = xScale.min;
    const currentMax = xScale.max;
    const range = currentMax - currentMin;
    
    // Calculate how much space to add on the right
    const shiftSpace = range * chartShiftAmount;
    
    // Apply the shift by extending the max boundary
    currentChart.options.scales.x.max = currentMax + shiftSpace;
    
    // Update the chart to show the shift
    currentChart.update('none');
}

function updateChartShiftPosition() {
    if (!currentChart || !chartShiftTriangle) return;
    
    const chartArea = currentChart.chartArea;
    if (!chartArea) return;
    
    // Position triangle at the right edge with shift offset
    const handleX = chartArea.right - (chartArea.right - chartArea.left) * chartShiftAmount;
    chartShiftTriangle.style.left = `${handleX}px`;
    chartShiftTriangle.style.top = `${chartArea.top}px`;
    chartShiftTriangle.style.display = 'block';
}

function updateShiftPriceTimeDisplay(e) {
    if (!currentChart || !isDraggingShift) return;
    
    const chartArea = currentChart.chartArea;
    const yScale = currentChart.scales.y;
    const xScale = currentChart.scales.x;
    
    if (!chartArea || !yScale || !xScale) return;
    
    // Get current price at cursor position
    const rect = document.querySelector('.chart-wrapper').getBoundingClientRect();
    const y = e.clientY - rect.top;
    const boundedY = Math.max(chartArea.top, Math.min(chartArea.bottom, y));
    const price = yScale.getValueForPixel(boundedY);
    
    // Get current time at cursor position
    const x = e.clientX - rect.left;
    const timeValue = xScale.getValueForPixel(x);
    const timeText = timeValue ? new Date(timeValue).toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    }) : '';
    
    // Create or update shift display
    let shiftDisplay = document.getElementById('chartShiftDisplay');
    if (!shiftDisplay) {
        shiftDisplay = document.createElement('div');
        shiftDisplay.id = 'chartShiftDisplay';
        shiftDisplay.className = 'chart-shift-display';
        document.querySelector('.chart-wrapper').appendChild(shiftDisplay);
    }
    
    shiftDisplay.innerHTML = `${price.toFixed(5)}<br>${timeText}`;
    shiftDisplay.style.left = `${e.clientX + 10}px`;
    shiftDisplay.style.top = `${e.clientY - 30}px`;
    shiftDisplay.style.display = 'block';
}

// Enhanced Zoom System with Mode Activation - FIXED
let isZoomModeActive = false;
let currentZoomMode = null; // 'in' or 'out'
let currentZoomLevel = 2; // Start at 1x zoom
const ZOOM_LEVELS = [0.5, 0.7, 1, 1.5, 2, 3, 5];

function zoomIn() {
    if (!currentChart) return;
    
    // Activate zoom IN mode
    isZoomModeActive = true;
    currentZoomMode = 'in';
    currentChart.options.plugins.zoom.zoom.drag.enabled = true;
    currentChart.update('none');
    
    // Update button visual state
    updateZoomButtonState('in');
    
    console.log('ðŸ” Zoom IN mode activated');
}

function zoomOut() {
    if (!currentChart) return;
    
    // Activate zoom OUT mode
    isZoomModeActive = true;
    currentZoomMode = 'out';
    currentChart.options.plugins.zoom.zoom.drag.enabled = true;
    currentChart.update('none');
    
    // Update button visual state
    updateZoomButtonState('out');
    
    console.log('ðŸ” Zoom OUT mode activated');
}

function resetZoom() {
    if (!currentChart) return;
    
    // Reset zoom and deactivate mode
    isZoomModeActive = false;
    currentZoomMode = null;
    currentZoomLevel = 2;
    currentChart.resetZoom();
    currentChart.options.plugins.zoom.zoom.drag.enabled = false;
    currentChart.update('none');
    
    // Reset button visual state
    updateZoomButtonState('reset');
    
    console.log('ðŸ”„ Zoom reset');
}

function updateZoomButtonState(mode) {
    const zoomInBtn = document.querySelector('.control-btn');
    const zoomOutBtn = document.querySelectorAll('.control-btn')[2]; // Assuming zoom out is 3rd button
    
    if (mode === 'in') {
        if (zoomInBtn && zoomInBtn.textContent.includes('ðŸ”+')) {
            zoomInBtn.innerHTML = 'ðŸ”+ ACTIVE';
            zoomInBtn.classList.add('active');
        }
        if (zoomOutBtn && zoomOutBtn.textContent.includes('ACTIVE')) {
            zoomOutBtn.innerHTML = 'ðŸ”-';
            zoomOutBtn.classList.remove('active');
        }
    } else if (mode === 'out') {
        if (zoomOutBtn && zoomOutBtn.textContent.includes('ðŸ”-')) {
            zoomOutBtn.innerHTML = 'ðŸ”- ACTIVE';
            zoomOutBtn.classList.add('active');
        }
        if (zoomInBtn && zoomInBtn.textContent.includes('ACTIVE')) {
            zoomInBtn.innerHTML = 'ðŸ”+';
            zoomInBtn.classList.remove('active');
        }
    } else if (mode === 'reset') {
        if (zoomInBtn && zoomInBtn.textContent.includes('ACTIVE')) {
            zoomInBtn.innerHTML = 'ðŸ”+';
            zoomInBtn.classList.remove('active');
        }
        if (zoomOutBtn && zoomOutBtn.textContent.includes('ACTIVE')) {
            zoomOutBtn.innerHTML = 'ðŸ”-';
            zoomOutBtn.classList.remove('active');
        }
    }
}

function applyFixedZoom() {
    if (!currentChart) return;
    
    const zoomMultiplier = ZOOM_LEVELS[currentZoomLevel];
    currentChart.zoom(zoomMultiplier);
}

// Enhanced Crosshair System - FIXED
function initializeAxisIndicators() {
    if (axisIndicators.yIndicator) axisIndicators.yIndicator.remove();
    if (axisIndicators.xIndicator) axisIndicators.xIndicator.remove();
    
    const chartWrapper = document.querySelector('.chart-wrapper');
    if (!chartWrapper) return;
    
    const yIndicator = document.createElement('div');
    yIndicator.className = 'axis-indicator y-axis-indicator';
    yIndicator.id = 'yAxisIndicator';
    yIndicator.style.display = 'none';
    
    const xIndicator = document.createElement('div');
    xIndicator.className = 'axis-indicator x-axis-indicator';
    xIndicator.id = 'xAxisIndicator';
    xIndicator.style.display = 'none';
    
    chartWrapper.appendChild(yIndicator);
    chartWrapper.appendChild(xIndicator);
    
    axisIndicators.yIndicator = yIndicator;
    axisIndicators.xIndicator = xIndicator;
}

function updateAxisIndicators(x, y, price, time) {
    if (!axisIndicators.yIndicator || !axisIndicators.xIndicator) return;
    
    const chartArea = currentChart?.chartArea;
    if (!chartArea) return;
    
    // Keep indicators within chart bounds
    const boundedX = Math.max(chartArea.left, Math.min(chartArea.right, x));
    const boundedY = Math.max(chartArea.top, Math.min(chartArea.bottom, y));
    
    if (price !== null && boundedY >= chartArea.top && boundedY <= chartArea.bottom) {
        axisIndicators.yIndicator.textContent = price.toFixed(5);
        axisIndicators.yIndicator.style.top = `${boundedY}px`;
        axisIndicators.yIndicator.style.right = '0px';
        axisIndicators.yIndicator.style.display = 'block';
    } else {
        axisIndicators.yIndicator.style.display = 'none';
    }
    
    if (time && boundedX >= chartArea.left && boundedX <= chartArea.right) {
        axisIndicators.xIndicator.textContent = time;
        axisIndicators.xIndicator.style.left = `${boundedX}px`;
        axisIndicators.xIndicator.style.bottom = '0px';
        axisIndicators.xIndicator.style.display = 'block';
    } else {
        axisIndicators.xIndicator.style.display = 'none';
    }
}

function hideAxisIndicators() {
    if (axisIndicators.yIndicator) axisIndicators.yIndicator.style.display = 'none';
    if (axisIndicators.xIndicator) axisIndicators.xIndicator.style.display = 'none';
}

function addCrosshairListeners() {
    const canvas = document.getElementById('mainChart');
    if (!canvas) return;

    crosshairVisible = false;
    crosshairX = 0;
    crosshairY = 0;
    crosshairPrice = null;

    canvas.addEventListener('mousemove', function(event) {
        if (tooltipLocked) return;
        if (!crosshairEnabled || !currentChart) return;
        
        const rect = canvas.getBoundingClientRect();
        crosshairX = event.clientX - rect.left;
        crosshairY = event.clientY - rect.top;
        crosshairVisible = true;
        
        const chartArea = currentChart.chartArea;
        const yScale = currentChart.scales.y;
        
        if (yScale && chartArea) {
            const value = yScale.getValueForPixel(crosshairY);
            crosshairPrice = value;
            
            updateCurrentPrice(value);
            
            const xScale = currentChart.scales.x;
            const timeValue = xScale.getValueForPixel(crosshairX);
            const timeText = timeValue ? new Date(timeValue).toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            }) : '';
            
            updateAxisIndicators(crosshairX, crosshairY, value, timeText);
        }
        
        if (currentChart) currentChart.draw();
    });

    canvas.addEventListener('mouseleave', function() {
        crosshairVisible = false;
        crosshairPrice = null;
        hideAxisIndicators();
        if (currentChart) currentChart.draw();
    });

    if (currentChart) {
        const originalDraw = currentChart.draw;
        currentChart.draw = function() {
            originalDraw.call(this);
            if (crosshairEnabled) drawCrosshair();
        };
    }
}

function drawCrosshair() {
    if (!crosshairEnabled || !crosshairVisible || !currentChart) return;

    const ctx = currentChart.ctx;
    const chartArea = currentChart.chartArea;
    
    // Keep crosshair within chart bounds
    const boundedX = Math.max(chartArea.left, Math.min(chartArea.right, crosshairX));
    const boundedY = Math.max(chartArea.top, Math.min(chartArea.bottom, crosshairY));
    
    if (boundedX < chartArea.left || boundedX > chartArea.right || boundedY < chartArea.top || boundedY > chartArea.bottom) return;

    ctx.save();
    ctx.strokeStyle = '#E2E8F0';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    
    ctx.beginPath();
    ctx.moveTo(boundedX, chartArea.top);
    ctx.lineTo(boundedX, chartArea.bottom);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(chartArea.left, boundedY);
    ctx.lineTo(chartArea.right, boundedY);
    ctx.stroke();
    
    ctx.restore();
}

// Tooltip positioning (manual only - no hover) - FIXED
function triggerTooltipAtTime(timestamp) {
    if (!currentChart) return;
    
    const xScale = currentChart.scales.x;
    if (!xScale) return;
    
    const pixel = xScale.getPixelForValue(new Date(timestamp));
    const chartArea = currentChart.chartArea;
    if (!chartArea) return;
    
    if (pixel < chartArea.left || pixel > chartArea.right) return;
    
    const canvas = document.getElementById('mainChart');
    const mockEvent = new MouseEvent('mousemove', {
        clientX: canvas.getBoundingClientRect().left + pixel,
        clientY: canvas.getBoundingClientRect().top + chartArea.top + (chartArea.bottom - chartArea.top) / 2
    });
    
    canvas.dispatchEvent(mockEvent);
    console.log(`ðŸŽ¯ Tooltip triggered at: ${new Date(timestamp).toLocaleString()}`);
}

// Chart controls and utilities
function setChartType(type) {
    currentChartType = type;
    
    const chartTypeSelect = document.getElementById('chartTypeSelect');
    if (chartTypeSelect) {
        chartTypeSelect.value = type;
    }
    
    if (currentTimeframe) {
        loadChart(currentTimeframe);
    }
}

function updateChartTimeframe() {
    const timeframe = document.getElementById('timeframeSelect').value;
    loadChart(timeframe);
}

function toggleCrosshair() {
    crosshairEnabled = !crosshairEnabled;
    const crosshairBtn = document.querySelector('.control-btn');
    
    if (crosshairBtn && crosshairBtn.textContent.includes('Cross')) {
        if (crosshairEnabled) {
            crosshairBtn.innerHTML = 'âŠ• Cross ON';
            crosshairBtn.classList.add('active');
        } else {
            crosshairBtn.innerHTML = 'âŠ• Cross OFF';
            crosshairBtn.classList.remove('active');
        }
    }
    
    if (currentChart) currentChart.draw();
}

function downloadChart() {
    if (!currentChart) return;
    
    const canvas = document.getElementById('mainChart');
    const link = document.createElement('a');
    link.download = `chart-${currentPair}-${currentTimeframe}-${new Date().toISOString().split('T')[0]}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// Chart time utilities
function getProfessionalTimeUnit(timeframe) {
    const units = {
        'M1': 'minute', 'M5': 'minute', 'M15': 'minute',
        'H1': 'hour', 'H4': 'hour', 'D1': 'day'
    };
    return units[timeframe] || 'hour';
}

function getProfessionalTimeFormats(timeframe) {
    return {
        minute: 'HH:mm',
        hour: 'MMM dd HH:mm',
        day: 'MMM dd, yyyy'
    };
}

// Current price display - FIXED
function updateCurrentPrice(price) {
    const currentPriceElement = document.getElementById('currentPrice');
    if (currentPriceElement && price) {
        const currentPriceValue = typeof price === 'number' ? price.toFixed(5) : price;
        currentPriceElement.textContent = currentPriceValue;
        
        const lastPrice = parseFloat(currentPriceElement.dataset.lastPrice) || price;
        
        // Update color based on price movement
        if (price > lastPrice) {
            currentPriceElement.style.color = 'var(--green)';
            currentPriceElement.style.borderColor = 'var(--green-border)';
            currentPriceElement.classList.add('up');
            currentPriceElement.classList.remove('down', 'neutral');
            updateCurrentPriceLine(price, 'up');
        } else if (price < lastPrice) {
            currentPriceElement.style.color = 'var(--red)';
            currentPriceElement.style.borderColor = 'var(--red-border)';
            currentPriceElement.classList.add('down');
            currentPriceElement.classList.remove('up', 'neutral');
            updateCurrentPriceLine(price, 'down');
        } else {
            currentPriceElement.style.color = 'var(--gray)';
            currentPriceElement.style.borderColor = 'var(--gray-border)';
            currentPriceElement.classList.add('neutral');
            currentPriceElement.classList.remove('up', 'down');
            updateCurrentPriceLine(price, 'neutral');
        }
        
        currentPriceElement.dataset.lastPrice = price;
    }
}