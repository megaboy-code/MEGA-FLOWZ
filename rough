// ==================== CHART SYSTEM - FORCED WHITE THEME ====================
function renderProfessionalChart(chartData, timeframe, symbol, indicators, indicators_data) {
    const ctx = document.getElementById('mainChart').getContext('2d');
  
    if (currentChart) currentChart.destroy();
    currentIndicatorValues = indicators || {};
  
    const professionalTheme = {
        primary: '#3A86FF', // Force blue line color
        background: 'rgba(58, 134, 255, 0.15)'
    };
    
    let datasets = [];
    if (currentChartType === 'line') {
        datasets = createLineDataset(chartData, symbol, professionalTheme);
    } else if (currentChartType === 'area') {
        datasets = createAreaDataset(chartData, symbol, professionalTheme);
    } else if (currentChartType === 'candlestick') {
        datasets = createCandlestickDataset(chartData, symbol, professionalTheme);
    } else if (currentChartType === 'trend') {
        datasets = createLineDataset(chartData, symbol, professionalTheme);
    }
    datasets = datasets.concat(createIndicatorDatasets(indicators_data, professionalTheme));
    const chartType = currentChartType === 'candlestick' ? 'candlestick' : 'line';
  
    currentChart = new Chart(ctx, {
        type: chartType,
        data: { datasets: datasets },
        options: getEnhancedChartOptions(timeframe)
    });
    
    initializeCurrentPriceLevel();
    initializeCrosshairDisplay();
    addCrosshairListeners();
    initializeChartScroll();
    renderIndicatorsList();
  
    const latestPrice = chartData.length > 0 ? chartData[chartData.length - 1].y : 0;
    updateCurrentPrice(latestPrice);
    updateCurrentPriceLevel(latestPrice, 'neutral');
  
    console.log(`âœ… Chart rendered: ${symbol} ${timeframe} (${currentChartType})`);
}

// FORCED WHITE THEME - Text, Grid, Borders all WHITE
function getEnhancedChartOptions(timeframe) {
    return {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            mode: 'nearest',
            intersect: false,
            axis: 'xy'
        },
        plugins: {
            legend: {
                display: false
            },
            tooltip: {
                enabled: false
            },
            zoom: {
                zoom: {
                    drag: {
                        enabled: false,
                        modifierKey: null
                    },
                    wheel: {
                        enabled: false
                    },
                    pinch: {
                        enabled: false
                    },
                    mode: 'xy'
                },
                pan: {
                    enabled: true,
                    mode: 'xy',
                    modifierKey: 'shift'
                },
                limits: {
                    x: { min: 'original', max: 'original' },
                    y: { min: 'original', max: 'original' }
                }
            }
        },
        scales: {
            x: {
                type: 'time',
                time: {
                    displayFormats: getProfessionalTimeFormats(timeframe)
                },
                grid: {
                    color: '#ffffff', // FORCE WHITE grid lines
                    lineWidth: 1,
                    drawBorder: true,
                    border: {
                        color: '#ffffff', // FORCE WHITE axis border
                        width: 2
                    }
                },
                ticks: {
                    color: '#ffffff', // FORCE WHITE text for time
                    maxRotation: 0,
                    autoSkip: true,
                    maxTicksLimit: 8,
                    padding: 8,
                    font: {
                        size: 11,
                        weight: '500',
                        family: "'Inter', 'Segoe UI', sans-serif"
                    }
                },
                border: {
                    display: true,
                    color: '#ffffff', // FORCE WHITE axis border
                    width: 2
                }
            },
            y: {
                position: 'right',
                grid: {
                    color: '#ffffff', // FORCE WHITE grid lines
                    lineWidth: 1,
                    drawBorder: true,
                    border: {
                        color: '#ffffff', // FORCE WHITE axis border
                        width: 2
                    }
                },
                ticks: {
                    color: '#ffffff', // FORCE WHITE text for price
                    callback: (value) => value.toFixed(5),
                    maxTicksLimit: 10,
                    padding: 8,
                    font: {
                        size: 11,
                        weight: '500',
                        family: "'Inter', 'Segoe UI', sans-serif"
                    }
                },
                border: {
                    display: true,
                    color: '#ffffff', // FORCE WHITE axis border
                    width: 2
                }
            },
            y2: {
                type: 'linear',
                position: 'left',
                grid: { 
                    drawOnChartArea: false,
                    color: '#ffffff' // FORCE WHITE grid
                },
                ticks: {
                    color: '#ffffff', // FORCE WHITE text
                    callback: (value) => value.toFixed(2),
                    maxTicksLimit: 5,
                    padding: 8,
                    font: {
                        size: 11,
                        weight: '500',
                        family: "'Inter', 'Segoe UI', sans-serif"
                    }
                },
                border: {
                    display: true,
                    color: '#ffffff', // FORCE WHITE axis border
                    width: 2
                },
                min: 0,
                max: 100
            }
        },
        // Force chart background
        onResize: (chart, size) => {
            chart.canvas.style.backgroundColor = '#151a21'; // Dark background for contrast
        }
    };
}

// Keep all your existing dataset functions the same
function createCandlestickDataset(priceData, symbol, theme) {
    return [{
        label: `${symbol} Price`,
        data: priceData,
        borderColor: theme.primary,
        backgroundColor: 'transparent',
        borderWidth: 2,
        pointRadius: 0,
        pointHoverRadius: 3,
        tension: 0.1,
        yAxisID: 'y',
        fill: false
    }];
}

function createLineDataset(priceData, symbol, theme) {
    if (currentChartType === 'trend') {
        return [{
            label: `${symbol} Price`, data: priceData,
            segment: { borderColor: (ctx) => {
                if (ctx.p0.parsed.y === ctx.p1.parsed.y) return theme.primary;
                return ctx.p1.parsed.y > ctx.p0.parsed.y ? '#00D394' : '#FF4D4D';
            }},
            borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, tension: 0.1, yAxisID: 'y', fill: false
        }];
    } else {
        return [{
            label: `${symbol} Price`, data: priceData, borderColor: theme.primary, backgroundColor: 'transparent',
            borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, tension: 0.1, yAxisID: 'y', fill: false
        }];
    }
}

function createAreaDataset(priceData, symbol, theme) {
    return [{
        label: `${symbol} Price`, data: priceData, borderColor: theme.primary, backgroundColor: theme.background,
        borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, tension: 0.1, yAxisID: 'y',
        fill: { target: 'origin', above: theme.background }
    }];
}

function createIndicatorDatasets(indicators_data, theme) {
    const datasets = [];
    if (!indicators_data) return datasets;
  
    activeIndicators.forEach((config, indicatorId) => {
        if (!config.visible) return;
        const baseType = indicatorId.split('_')[0];
      
        switch(baseType) {
            case 'bollinger':
                if (indicators_data.bollinger) {
                    const bb = indicators_data.bollinger;
                    datasets.push(
                        { label: `${config.name} Upper`, data: bb.upper, borderColor: config.color, borderWidth: 1, pointRadius: 0, yAxisID: 'y', fill: false },
                        { label: `${config.name} Middle`, data: bb.middle, borderColor: config.color, borderWidth: 1.5, pointRadius: 0, yAxisID: 'y', fill: false },
                        { label: `${config.name} Lower`, data: bb.lower, borderColor: config.color, borderWidth: 1, pointRadius: 0, yAxisID: 'y', fill: false }
                    );
                }
                break;
            case 'stochastic':
                if (indicators_data.stoch_k) {
                    datasets.push({ label: `${config.name} %K`, data: indicators_data.stoch_k, borderColor: config.color, borderWidth: 1.5, pointRadius: 0, yAxisID: 'y2', fill: false });
                }
                if (indicators_data.stoch_d) {
                    datasets.push({ label: `${config.name} %D`, data: indicators_data.stoch_d, borderColor: config.color, borderWidth: 1.5, borderDash: [5, 5], pointRadius: 0, yAxisID: 'y2', fill: false });
                }
                break;
            case 'supportresistance':
                if (indicators_data.support_resistance) {
                    datasets.push({ label: 'Support/Resistance', data: [], srLevels: indicators_data.support_resistance, supportColor: config.supportColor, resistanceColor: config.resistanceColor });
                }
                break;
            default:
                const instanceNumber = config.instanceNumber;
                const dataKeys = [`${baseType}_${config.period}`, `${baseType}_${instanceNumber}`, baseType, `${baseType}_20`, `${baseType}_12`];
              
                let indicatorData = null;
                for (const key of dataKeys) {
                    if (indicators_data[key]) {
                        indicatorData = indicators_data[key];
                        break;
                    }
                }
              
                if (indicatorData) {
                    datasets.push({
                        label: `${config.name} #${instanceNumber}`, data: indicatorData, borderColor: config.color, borderWidth: 1.5,
                        borderDash: baseType === 'ema' ? [2, 2] : [0, 0], pointRadius: 0, tension: 0, yAxisID: config.yAxis || 'y', fill: false
                    });
                }
                break;
        }
    });
    return datasets;
}

// Keep all your other chart functions the same (loadChart, buildIndicatorParameters, etc.)